# Дан список повторяющихся элементов. Вернуть список с дублирующимися элементами. 
# В результирующем списке не должно быть дубликатов.

list_1 = [3,5,2,4,6,2,3,45,2,3,5,26,6,2,2]
list_uniqe = list(set(list_1))
print(list_uniqe)

# В большой текстовой строке подсчитать количество встречаемых слов и вернуть
# 10 самых частых. Не учитывать знаки препинания и регистр символов. 
# За основу возьмите любую статью из википедии или из документации к языку.

text = 'Множество (Set) — структура данных, которая позволяет достаточно быстро (в зависимости от реализации) применить операции add, erase и is_in_set. Но иногда этого не достаточно: например, невозможно перебрать все элементы в порядке возрастания, получить следующий предыдущий по величине или быстро узнать, сколько элементов меньше данного есть в множестве. В таких случаях приходится использовать Упорядоченное множество (ordered_set). О том, как оно работает, и какие реализации есть для питона — далее. Стандартный Set/ В языке Python есть стандартная стукрура set, реализованная с помощью хэш-таблиц. Такую структуру обычно называют unordered_set. Данный метод работает так: каждый элемент присваивается какому-то классу элементов (например, класс элементов, имеющих одинаковый остаток от деления на модуль). Все элементы каждого класса хранятся в отдельном списке. В таком случае мы заранее знаем, в каком списке должен находиться элемент, и можем за короткое время выполнить необходимые операции. Равновероятность каждого остатка от деления случайного числа на модуль позволяет сказать, что к каждому классу элементов будет относиться в среднем size modulo элементов. Но хэш-таблица не позволяет выполнить операцию count_lower или подобные, поэтому придётся использовать другие структуры данных. поэтому поэтому поэтому поэтому поэтому'
list_2 = text.split()
freq_list = {}
for item in list_2:
    if freq_list.get(item) != None:
        freq_list[item] += 1
    else:
        freq_list[item] = 1
for _ in range(0, 10):
    MAX = 0
    for key, values in freq_list.items():
        if values > MAX:
            max_key = key
            MAX +=1
    print(max_key, ':', freq_list[max_key])
    freq_list.pop(max_key)
    
    # Создайте словарь со списком вещей для похода в качестве ключа и их массой в качестве значения. Определите какие вещи влезут в рюкзак передав его максимальную грузоподъёмность. Достаточно вернуть один допустимый вариант. *Верните все возможные варианты комплектации рюкзака.
    
import copy
VOLUME = 20
count = 1
weight = 0
supply = {'палатка':5, 'еда':5, 'вода':2.5, 'топор': 0.5, 'спальник': 0.5, 'котелок': 2,'алкоголь':5 , 'удочки':2.9, 'лодка':7, 'бумажник':0.2, 'одежда':4}
for key in supply.keys():
    supply_copy = copy.deepcopy(supply)
    set = key + ' '
    weight = supply_copy[key]
    supply_copy.pop(key)
    while weight < VOLUME:
        max_thing = ''
        MAX = 0
        for key, values in supply_copy.items():
            if values > MAX:
                max_thing = key
                MAX = supply_copy[max_thing]
        if weight + MAX <= VOLUME:
            set += max_thing + ' '
            weight += MAX    
        if max_thing == '':
            break
        supply_copy.pop(max_thing)
    print (f'Набор {count}: {set}, вес = {weight}')
    count +=1
            
